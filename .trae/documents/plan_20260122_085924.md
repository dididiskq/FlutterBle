# 实现表格3保护时间和保护事件处理

## 需求分析
- 需要实现 `_processTable3Response` 函数中第3249行的保护时间和保护事件处理
- 参考 `_readProtectionTime` 和 `_readProtectionEvent` 函数的实现逻辑
- 表格3包含24个保护时间和24个保护事件，每个占用4字节
- 需要解析这些数据并更新电池数据对象

## 实现步骤

### 1. 分析现有函数逻辑

#### `_readProtectionTime` 函数
- 读取4字节数据，解析为年月日时分秒格式
- 格式：`(year << 26) | (month << 22) | (day << 17) | (hour << 12) | (minute << 6) | second`
- year 从2022年开始计算

#### `_readProtectionEvent` 函数
- 读取4字节数据，转换为16进制字符串

### 2. 实现保护时间和保护事件解析

#### 保护时间解析逻辑
1. 遍历24个保护时间，每个占用4字节
2. 解析每个保护时间为年月日时分秒格式
3. 存储解析结果

#### 保护事件解析逻辑
1. 遍历24个保护事件，每个占用4字节
2. 解析每个保护事件为16进制字符串
3. 存储解析结果

### 3. 更新电池数据对象
- 将解析后的保护时间和保护事件更新到电池数据对象中

## 具体实现

**文件**：`d:\pro\vscodePro\FlutterPro\untitled1\lib\managers\battery_data_manager.dart`

**修改内容**：更新 `_processTable3Response` 函数，添加保护时间和保护事件处理

```dart
void _processTable3Response(List<int> bytes) {
  print('[BatteryDataManager] 处理表格3数据响应 (${bytes.length}字节)');
  if (bytes.isEmpty) {
    return;
  }

  int offset = 0;
  
  // 设计循环次数 (Uint16)
  final designCycleCount = (bytes[offset] << 8) | bytes[offset + 1];
  offset += 2;
  
  // 循环次数 (Uint16)
  final cycleCount = (bytes[offset] << 8) | bytes[offset + 1];
  offset += 2;
  
  // 满充容量 (Uint32, mah)
  final fullCapacity = (bytes[offset] << 24) | (bytes[offset + 1] << 16) | (bytes[offset + 2] << 8) | bytes[offset + 3];
  offset += 4;
  
  // 设计容量 (Uint32, mah)
  final designCapacity = (bytes[offset] << 24) | (bytes[offset + 1] << 16) | (bytes[offset + 2] << 8) | bytes[offset + 3];
  offset += 4;
  
  // 最大的未充电隔间时间 (Uint16, h)
  final maxUnchargedInterval = (bytes[offset] << 8) | bytes[offset + 1];
  offset += 2;
  
  // 最近的未充电隔间时间 (Uint16, h)
  final recentUnchargedInterval = (bytes[offset] << 8) | bytes[offset + 1];
  offset += 2;
  
  // BT码 (string, 32字节)
  final btCode = String.fromCharCodes(bytes.sublist(offset, offset + 32)).trim();
  offset += 32;
  
  // 解析24个保护时间
  final protectionTimes = <String>[];
  for (int i = 0; i < 24 && offset + 3 < bytes.length; i++) {
    final a = (bytes[offset] << 24) | (bytes[offset + 1] << 16) | (bytes[offset + 2] << 8) | bytes[offset + 3];
    offset += 4;
    
    if (a == 0) {
      protectionTimes.add('');
      continue;
    }
    
    final year = ((a & 0xFC000000) >> 26) + 2022;
    final month = (a & 0x03C00000) >> 22;
    final day = (a & 0x003E0000) >> 17;
    final hour = (a & 0x0001F000) >> 12;
    final minute = (a & 0x00000FC0) >> 6;
    final second = a & 0x0000003F;
    
    final timeStr = '${year}-${month.toString().padLeft(2, '0')}-${day.toString().padLeft(2, '0')} ' 
                  '${hour.toString().padLeft(2, '0')}:${minute.toString().padLeft(2, '0')}:${second.toString().padLeft(2, '0')}';
    
    protectionTimes.add(timeStr);
    print('[BatteryDataManager] [Protection] 保护时间 ${i + 1}: $timeStr');
  }
  
  // 解析24个保护事件
  final protectionEvents = <String>[];
  for (int i = 0; i < 24 && offset + 3 < bytes.length; i++) {
    final a = (bytes[offset] << 24) | (bytes[offset + 1] << 16) | (bytes[offset + 2] << 8) | bytes[offset + 3];
    offset += 4;
    
    if (a == 0) {
      protectionEvents.add('');
      continue;
    }
    
    final eventStr = '0x${a.toRadixString(16).padLeft(8, '0').toUpperCase()}';
    
    protectionEvents.add(eventStr);
    print('[BatteryDataManager] [Protection] 保护事件 ${i + 1}: $eventStr');
  }
  
  // 更新电池数据
  _currentData = _currentData.copyWith(
    designCycleCount: designCycleCount,
    cycleCount: cycleCount,
    fullCapacity: fullCapacity / 1000.0, // 转换为Ah
    capacity: designCapacity / 1000.0, // 转换为Ah
    maxUnchargedInterval: maxUnchargedInterval,
    recentUnchargedInterval: recentUnchargedInterval,
    btCode: btCode,
    timestamp: DateTime.now(),
  );
  
  _batteryDataController.add(_currentData);
  print('[BatteryDataManager] 表格3数据已更新');
}
```

## 预期效果
- 当收到表格3数据响应时，能够正确解析24个保护时间和24个保护事件
- 解析后的保护时间格式为 `YYYY-MM-DD HH:MM:SS`
- 解析后的保护事件格式为 `0xXXXXXXXX`
- 解析结果会打印到日志中
- 电池数据对象会被更新

## 注意事项
- 确保数据解析时不会越界访问
- 处理数据为0的情况
- 保持与现有代码风格一致
- 不影响现有功能