## 问题分析

1. **当前逻辑**：
   - 扫码结果用`|`分割，Android用parts[0]，iOS用parts[1]连接
   - 只支持"mac|uuid"格式的二维码

2. **新需求**：
   - 支持两种二维码：
     - 第一种：只有mac地址（Android老设备）
     - 第二种："mac|name"格式（新设备）
   - Android：
     - 第一种二维码：直接用mac连接
     - 第二种二维码：取mac连接
   - iOS：
     - 第一种二维码：无法连接（缺少name）
     - 第二种二维码：取name，扫描蓝牙设备，匹配成功则用该设备的uuid连接

## 解决方案

1. **修改`ScanPage._handleScanResult`**：
   - 解析两种二维码格式
   - 根据平台和二维码格式选择连接策略

2. **新增`BleController.scanAndFindDeviceByName`**：
   - 扫描蓝牙设备
   - 根据设备名称匹配设备
   - 返回匹配到的设备ID（uuid）

3. **调整连接流程**：
   - Android：直接用mac连接
   - iOS：先扫描匹配设备，再用uuid连接

## 实现步骤

1. **修改`ScanPage._handleScanResult`方法**：
   - 解析二维码内容，判断格式
   - 根据平台选择连接逻辑
   - Android：直接调用connectToDevice
   - iOS：调用新增的scanAndFindDeviceByName方法，匹配成功后连接

2. **在`BleController`中新增方法**：
   - `scanAndFindDeviceByName`：扫描设备并根据名称匹配
   - 实现设备扫描和匹配逻辑
   - 返回匹配到的设备ID

3. **测试各种场景**：
   - Android使用第一种二维码
   - Android使用第二种二维码
   - iOS使用第二种二维码
   - 处理匹配失败的情况

## 预期效果

- 支持两种二维码格式
- 适配Android和iOS平台
- 新老设备兼容
- 连接逻辑清晰，易于维护