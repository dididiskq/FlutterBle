# 实现表格2和表格3数据响应解析函数

## 需求分析
- 需要根据 `analyze_output.txt` 中提供的表格2和表格3结构，实现对应的响应解析函数
- 表格2包含电池组串数、电池类型、硬件版本、开关配置等参数
- 表格3包含设计循环次数、循环次数、满充容量、设计容量等参数
- 需要解析响应数据并更新电池数据对象

## 实现步骤

### 1. 实现 _processTable2Response 函数

#### 表格2结构分析
| 类型 | 单位 | 描述 | 字段名 |
|------|------|------|--------|
| Uint16 | s | 电池组串数 | CellNumber |
| Uint16 | - | 电池类型 | CellType |
| Uint16 | - | 模拟前端代号 | AFE Number |
| Uint16 | - | 客户代号 | Customer Number |
| Uint16 | - | 硬件版本 | 主版本（bit8~15）次版本（bit0~7） |
| Uint16 | - | 开关配置寄存器 | FunctionConfig |
| Uint16 | s | 休眠延时 | SleepDelay |
| Uint16 | s | 关机延时 | ShutDownDelay |
| Uint16 | 10mv | 额定充电电压 | 5460（表示54.6V） |
| Int16 | 10ma | 额定充电电流 | 200（表示2A.0） |
| Uint16 | mv | 满充电压(单节) |  |
| Int16 | ma | 满充电流 |  |
| Uint16 | s | 满充延时 |  |
| Int16 | ma | 零电流显示阈值 | 0_current_threshold |
| float | mΩ | 采样电阻值 | SampleRValue |
| Uint16 | mv | 过充保护电压 | OV（单节） |
| Uint16 | mv | 过充恢复电压 | OVR（单节） |
| Uint16 | ms | 过充延时OVT |  |
| Uint16 | mv | 低压禁充电电压 | VL0V |
| Uint16 | mv | 均衡启动电压 | 均衡开启电压 VOB（单节） |
| Uint16 | mv | 均衡启动阈值 | BALD |
| Uint16 | ms | 均衡延时 | BALT |
| Uint16 | mv | 过放保护电压 | UV（单节） |
| Uint16 | mv | 过放恢复电压 | UVR（单节） |
| Uint16 | ms | 过放延时UVT |  |
| Uint16 | A | 放电过流1保护电流 | OCD1 |
| Uint16 | ms | 放电过流1延时 | OCD1T |
| Uint16 | A | 放电过流2保护电 | OCD2 |
| Uint16 | ms | 放电过流2延时 | OCD2T |
| Uint16 | A | 短路保护电流 |  |
| Uint16 | us | 短路保护延时 | SCT |
| Uint16 | A | 充电过流保护电流 | OCC |
| Uint16 | ms | 充电过流延时 | OCCT |
| int16 | ℃ | 充电高温保护 | OTC |
| int16 | ℃ | 充电高温恢复 | OTCR |
| int16 | ℃ | 充电低温保护 | UTC |
| int16 | ℃ | 充电低温恢复 | UTCR |
| int16 | ℃ | 放电高温保护 | OTD |
| int16 | ℃ | 放电高温恢复 | OTDR |
| int16 | ℃ | 放电低温保护 | UTD |
| int16 | ℃ | 放电低温恢复 | UTDR |
| int16 | ℃ | MOS放电高温保护 | MOTD |
| int16 | ℃ | MOS放电高温恢复 | MOTDR |
| string | - | 电池SN | SN[12] |
| string | - | 制造厂家 | Manufacturer[8] |
| string | - | 制造厂商型号 | ManufacturerModel[24] |
| string | - | 客户名称 | CustomerName[8] |
| string | - | 客户型号 | CustomerModel[24] |
| string | - | 生产日期 | MNFDate[8] |

#### 实现逻辑
1. 解析每个字段，根据偏移量和类型提取数据
2. 转换单位（如将10mv转换为V）
3. 更新电池数据对象中的对应字段

### 2. 实现 _processTable3Response 函数

#### 表格3结构分析
| 类型 | 单位 | 描述 | 字段名 |
|------|------|------|--------|
| Uint16 | - | 设计循环次数 | 电芯容量衰减80%的循环次数 |
| Uint16 | - | 循环次数 | Cyclecount |
| Uint32 | mah | 满充容量 | FCC |
| Uint32 | mah | 设计容量 | DC |
| Uint16 | h | 最大的未充电隔间时间 | 单位为小时 |
| Uint16 | h | 最近的未充电隔间时间 | 单位为小时 |
| string | - | BT码 | BT[32] |
| Uint32 | -- | 第1个保护时间 |  |
| Uint32 | -- | 第2个保护时间 |  |
| ... | | | |
| Uint32 | | 第23个保护时间 | |
| Uint32 | | 第24个保护时间 | |
| Uint32 | -- | 第1个保护事件 |  |
| Uint32 | -- | 第2个保护事件 |  |
| ... | | | |
| Uint32 | | 第23个保护事件 | |
| Uint32 | | 第24个保护事件 | |

#### 实现逻辑
1. 解析前6个字段（设计循环次数、循环次数、满充容量、设计容量、最大未充电时间、最近未充电时间）
2. 解析BT码
3. 暂不处理保护时间和保护事件（可后续扩展）
4. 更新电池数据对象中的对应字段

## 具体实现

### 1. _processTable2Response 函数实现
```dart
void _processTable2Response(List<int> bytes) {
  print('[BatteryDataManager] 处理表格2数据响应 (${bytes.length}字节)');
  if (bytes.isEmpty) {
    return;
  }

  int offset = 0;
  
  // 电池组串数 (Uint16)
  final cellNumber = (bytes[offset] << 8) | bytes[offset + 1];
  offset += 2;
  
  // 电池类型 (Uint16)
  final cellType = (bytes[offset] << 8) | bytes[offset + 1];
  offset += 2;
  
  // 模拟前端代号 (Uint16)
  final afeNumber = (bytes[offset] << 8) | bytes[offset + 1];
  offset += 2;
  
  // 客户代号 (Uint16)
  final customerNumber = (bytes[offset] << 8) | bytes[offset + 1];
  offset += 2;
  
  // 硬件版本 (Uint16)
  final hardwareVersion = (bytes[offset] << 8) | bytes[offset + 1];
  offset += 2;
  
  // 开关配置寄存器 (Uint16)
  final functionConfig = (bytes[offset] << 8) | bytes[offset + 1];
  offset += 2;
  
  // 休眠延时 (Uint16, s)
  final sleepDelay = (bytes[offset] << 8) | bytes[offset + 1];
  offset += 2;
  
  // 关机延时 (Uint16, s)
  final shutdownDelay = (bytes[offset] << 8) | bytes[offset + 1];
  offset += 2;
  
  // 额定充电电压 (Uint16, 10mv)
  final ratedChargeVoltage = (bytes[offset] << 8) | bytes[offset + 1];
  offset += 2;
  
  // 额定充电电流 (Int16, 10ma)
  final ratedChargeCurrentRaw = (bytes[offset] << 8) | bytes[offset + 1];
  final ratedChargeCurrent = ratedChargeCurrentRaw > 32767 ? ratedChargeCurrentRaw - 65536 : ratedChargeCurrentRaw;
  offset += 2;
  
  // 满充电压(单节) (Uint16, mv)
  final fullChargeVoltage = (bytes[offset] << 8) | bytes[offset + 1];
  offset += 2;
  
  // 满充电流 (Int16, ma)
  final fullChargeCurrentRaw = (bytes[offset] << 8) | bytes[offset + 1];
  final fullChargeCurrent = fullChargeCurrentRaw > 32767 ? fullChargeCurrentRaw - 65536 : fullChargeCurrentRaw;
  offset += 2;
  
  // 满充延时 (Uint16, s)
  final fullChargeDelay = (bytes[offset] << 8) | bytes[offset + 1];
  offset += 2;
  
  // 零电流显示阈值 (Int16, ma)
  final zeroCurrentThresholdRaw = (bytes[offset] << 8) | bytes[offset + 1];
  final zeroCurrentThreshold = zeroCurrentThresholdRaw > 32767 ? zeroCurrentThresholdRaw - 65536 : zeroCurrentThresholdRaw;
  offset += 2;
  
  // 采样电阻值 (float, mΩ)
  final sampleResistance = _registersToFloat(bytes.sublist(offset, offset + 4));
  offset += 4;
  
  // 过充保护电压 (Uint16, mv)
  final overchargeProtectVoltage = (bytes[offset] << 8) | bytes[offset + 1];
  offset += 2;
  
  // 过充恢复电压 (Uint16, mv)
  final overchargeRecoverVoltage = (bytes[offset] << 8) | bytes[offset + 1];
  offset += 2;
  
  // 过充延时 (Uint16, ms)
  final overchargeDelay = (bytes[offset] << 8) | bytes[offset + 1];
  offset += 2;
  
  // 低压禁充电电压 (Uint16, mv)
  final lowVoltageForbidCharge = (bytes[offset] << 8) | bytes[offset + 1];
  offset += 2;
  
  // 均衡启动电压 (Uint16, mv)
  final balanceStartVoltage = (bytes[offset] << 8) | bytes[offset + 1];
  offset += 2;
  
  // 均衡启动阈值 (Uint16, mv)
  final balanceStartThreshold = (bytes[offset] << 8) | bytes[offset + 1];
  offset += 2;
  
  // 均衡延时 (Uint16, ms)
  final balanceDelay = (bytes[offset] << 8) | bytes[offset + 1];
  offset += 2;
  
  // 过放保护电压 (Uint16, mv)
  final overdischargeProtectVoltage = (bytes[offset] << 8) | bytes[offset + 1];
  offset += 2;
  
  // 过放恢复电压 (Uint16, mv)
  final overdischargeRecoverVoltage = (bytes[offset] << 8) | bytes[offset + 1];
  offset += 2;
  
  // 过放延时 (Uint16, ms)
  final overdischargeDelay = (bytes[offset] << 8) | bytes[offset + 1];
  offset += 2;
  
  // 放电过流1保护电流 (Uint16, A)
  final dischargeOvercurrent1Protect = (bytes[offset] << 8) | bytes[offset + 1];
  offset += 2;
  
  // 放电过流1延时 (Uint16, ms)
  final dischargeOvercurrent1Delay = (bytes[offset] << 8) | bytes[offset + 1];
  offset += 2;
  
  // 放电过流2保护电流 (Uint16, A)
  final dischargeOvercurrent2Protect = (bytes[offset] << 8) | bytes[offset + 1];
  offset += 2;
  
  // 放电过流2延时 (Uint16, ms)
  final dischargeOvercurrent2Delay = (bytes[offset] << 8) | bytes[offset + 1];
  offset += 2;
  
  // 短路保护电流 (Uint16, A)
  final shortCircuitProtect = (bytes[offset] << 8) | bytes[offset + 1];
  offset += 2;
  
  // 短路保护延时 (Uint16, us)
  final shortCircuitDelay = (bytes[offset] << 8) | bytes[offset + 1];
  offset += 2;
  
  // 充电过流保护电流 (Uint16, A)
  final chargeOvercurrentProtect = (bytes[offset] << 8) | bytes[offset + 1];
  offset += 2;
  
  // 充电过流延时 (Uint16, ms)
  final chargeOvercurrentDelay = (bytes[offset] << 8) | bytes[offset + 1];
  offset += 2;
  
  // 充电高温保护 (int16, ℃)
  final chargeHighTempProtectRaw = (bytes[offset] << 8) | bytes[offset + 1];
  final chargeHighTempProtect = chargeHighTempProtectRaw > 32767 ? chargeHighTempProtectRaw - 65536 : chargeHighTempProtectRaw;
  offset += 2;
  
  // 充电高温恢复 (int16, ℃)
  final chargeHighTempRecoverRaw = (bytes[offset] << 8) | bytes[offset + 1];
  final chargeHighTempRecover = chargeHighTempRecoverRaw > 32767 ? chargeHighTempRecoverRaw - 65536 : chargeHighTempRecoverRaw;
  offset += 2;
  
  // 充电低温保护 (int16, ℃)
  final chargeLowTempProtectRaw = (bytes[offset] << 8) | bytes[offset + 1];
  final chargeLowTempProtect = chargeLowTempProtectRaw > 32767 ? chargeLowTempProtectRaw - 65536 : chargeLowTempProtectRaw;
  offset += 2;
  
  // 充电低温恢复 (int16, ℃)
  final chargeLowTempRecoverRaw = (bytes[offset] << 8) | bytes[offset + 1];
  final chargeLowTempRecover = chargeLowTempRecoverRaw > 32767 ? chargeLowTempRecoverRaw - 65536 : chargeLowTempRecoverRaw;
  offset += 2;
  
  // 放电高温保护 (int16, ℃)
  final dischargeHighTempProtectRaw = (bytes[offset] << 8) | bytes[offset + 1];
  final dischargeHighTempProtect = dischargeHighTempProtectRaw > 32767 ? dischargeHighTempProtectRaw - 65536 : dischargeHighTempProtectRaw;
  offset += 2;
  
  // 放电高温恢复 (int16, ℃)
  final dischargeHighTempRecoverRaw = (bytes[offset] << 8) | bytes[offset + 1];
  final dischargeHighTempRecover = dischargeHighTempRecoverRaw > 32767 ? dischargeHighTempRecoverRaw - 65536 : dischargeHighTempRecoverRaw;
  offset += 2;
  
  // 放电低温保护 (int16, ℃)
  final dischargeLowTempProtectRaw = (bytes[offset] << 8) | bytes[offset + 1];
  final dischargeLowTempProtect = dischargeLowTempProtectRaw > 32767 ? dischargeLowTempProtectRaw - 65536 : dischargeLowTempProtectRaw;
  offset += 2;
  
  // 放电低温恢复 (int16, ℃)
  final dischargeLowTempRecoverRaw = (bytes[offset] << 8) | bytes[offset + 1];
  final dischargeLowTempRecover = dischargeLowTempRecoverRaw > 32767 ? dischargeLowTempRecoverRaw - 65536 : dischargeLowTempRecoverRaw;
  offset += 2;
  
  // MOS放电高温保护 (int16, ℃)
  final mosDischargeHighTempProtectRaw = (bytes[offset] << 8) | bytes[offset + 1];
  final mosDischargeHighTempProtect = mosDischargeHighTempProtectRaw > 32767 ? mosDischargeHighTempProtectRaw - 65536 : mosDischargeHighTempProtectRaw;
  offset += 2;
  
  // MOS放电高温恢复 (int16, ℃)
  final mosDischargeHighTempRecoverRaw = (bytes[offset] << 8) | bytes[offset + 1];
  final mosDischargeHighTempRecover = mosDischargeHighTempRecoverRaw > 32767 ? mosDischargeHighTempRecoverRaw - 65536 : mosDischargeHighTempRecoverRaw;
  offset += 2;
  
  // 电池SN (string, 12字节)
  final batterySN = String.fromCharCodes(bytes.sublist(offset, offset + 12)).trim();
  offset += 12;
  
  // 制造厂家 (string, 8字节)
  final manufacturer = String.fromCharCodes(bytes.sublist(offset, offset + 8)).trim();
  offset += 8;
  
  // 制造厂商型号 (string, 24字节)
  final manufacturerModel = String.fromCharCodes(bytes.sublist(offset, offset + 24)).trim();
  offset += 24;
  
  // 客户名称 (string, 8字节)
  final customerName = String.fromCharCodes(bytes.sublist(offset, offset + 8)).trim();
  offset += 8;
  
  // 客户型号 (string, 24字节)
  final customerModel = String.fromCharCodes(bytes.sublist(offset, offset + 24)).trim();
  offset += 24;
  
  // 生产日期 (string, 8字节)
  final mfgDate = String.fromCharCodes(bytes.sublist(offset, offset + 8)).trim();
  offset += 8;
  
  // 更新电池数据
  _currentData = _currentData.copyWith(
    cellNumber: cellNumber,
    cellType: cellType,
    afeNumber: afeNumber,
    customerNumber: customerNumber,
    functionSwitchConfig: functionConfig,
    batterySN: batterySN,
    manufacturer: manufacturer,
    manufacturerModel: manufacturerModel,
    customerName: customerName,
    customerModel: customerModel,
    mfgDate: mfgDate,
    timestamp: DateTime.now(),
  );
  
  _batteryDataController.add(_currentData);
  print('[BatteryDataManager] 表格2数据已更新');
}
```

### 2. _processTable3Response 函数实现
```dart
void _processTable3Response(List<int> bytes) {
  print('[BatteryDataManager] 处理表格3数据响应 (${bytes.length}字节)');
  if (bytes.isEmpty) {
    return;
  }

  int offset = 0;
  
  // 设计循环次数 (Uint16)
  final designCycleCount = (bytes[offset] << 8) | bytes[offset + 1];
  offset += 2;
  
  // 循环次数 (Uint16)
  final cycleCount = (bytes[offset] << 8) | bytes[offset + 1];
  offset += 2;
  
  // 满充容量 (Uint32, mah)
  final fullCapacity = (bytes[offset] << 24) | (bytes[offset + 1] << 16) | (bytes[offset + 2] << 8) | bytes[offset + 3];
  offset += 4;
  
  // 设计容量 (Uint32, mah)
  final designCapacity = (bytes[offset] << 24) | (bytes[offset + 1] << 16) | (bytes[offset + 2] << 8) | bytes[offset + 3];
  offset += 4;
  
  // 最大的未充电隔间时间 (Uint16, h)
  final maxUnchargedInterval = (bytes[offset] << 8) | bytes[offset + 1];
  offset += 2;
  
  // 最近的未充电隔间时间 (Uint16, h)
  final recentUnchargedInterval = (bytes[offset] << 8) | bytes[offset + 1];
  offset += 2;
  
  // BT码 (string, 32字节)
  final btCode = String.fromCharCodes(bytes.sublist(offset, offset + 32)).trim();
  offset += 32;
  
  // 跳过保护时间和保护事件（可后续扩展）
  
  // 更新电池数据
  _currentData = _currentData.copyWith(
    cycleCount: cycleCount,
    designCycleCount: designCycleCount,
    fullCapacity: fullCapacity / 1000.0, // 转换为Ah
    capacity: designCapacity / 1000.0, // 转换为Ah
    maxUnchargedInterval: maxUnchargedInterval,
    recentUnchargedInterval: recentUnchargedInterval,
    btCode: btCode,
    timestamp: DateTime.now(),
  );
  
  _batteryDataController.add(_currentData);
  print('[BatteryDataManager] 表格3数据已更新');
}
```

## 验证修改
- 运行 `flutter build apk --debug` 命令，确保修改后的代码可以正常构建

## 预期效果
- 当收到表格2和表格3的数据响应时，能够正确解析并更新电池数据
- 保留现有逻辑，不影响第一种蓝牙板的正常工作
- 为第二种蓝牙板提供完整的数据解析支持